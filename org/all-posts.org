#+hugo_base_dir: ../
#+seq_todo: TODO NEXT DONE
#+STARTUP: overview

* DONE How I Org, A Software Engineer's Process                        :productivity:personal_process:
CLOSED: [2022-08-10 Wed 20:56]
:PROPERTIES:
:EXPORT_FILE_NAME: how-i-org
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :topics '(Emacs "Org-mode")
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Emacs and Org-mode to track work, improve flow, and reduce (cognitive) stress"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :images '("https://rm.rmdashrf.net/ox-hugo/task-state-cover.png")
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-08-10 Wed 20:56]
:END:

** How I Org
I've encountered a half dozen or so personal productivity, task management, organization and motivation systems. (I will spare the list.) The latest I've read is David Allen's [[https://gettingthingsdone.com/][Getting Things Done]]. Having been there and done this, I read Allen's book with a "Just take me to the algorithm" mentality.

Also, I create software for living. Software development is an occupation that is both creative and technical. It's also a craft that is mostly performed at a computer and is now more virtual than ever. A lot of text in /Getting Things Done/ covers tools and techniques that support the algorithm, but are incidental: there are many ways to implement, track, and execute Allen's techniques. A salesperson's needs here are different than a manager's, are different than a software engineer's, and so on.

My own personal organization needs are nearly full-virtual. Either I'm in a virtual meeting, preparing for one, working on tasks from one, or---and what I do best---designing and writing code and building software products. And finally, I spend as much time as possible in the Emacs editor. There are many, many code editors and IDEs out there.  Yet once you've paid the admittedly steep learning curve for Emacs, it's the most effective "flow tool" I know of. What I do in Emacs, including this very text, I can get lost in, which means maximum productivity.

By the way, I do not mash up personal todos with my work as GTD encourages. I prefer a simpler in->due?->done for this part of my life. For personal work I use [[https://todoist.com/][Todoist]] for it's clean UX, mobile app, and sync across devices. Todoist recently added [[https://todoist.com/kanban-board][Kanban boards,]] so I may toy with a GTD-esque flow sans Emacs (which is a fiddly challenge to sync across devices.) That notwithstanding, I'll continue with my Emacs setup.

*** Why Emacs?
I admit, I've got years of Emacs key bindings in my fingers. But like playing the piano, practice makes plenty good. More keyboard, less mousing around many windows lends to good flow. I can now capture meeting notes, reference tidbits, fleeting ideas, and so on, with confidence I can forget them now, find them later, and fold follow ups into todo lists and projects plans.

*** References
The following works were highly influential in my own productivity thinking and, of course, this article. 
- [[https://gettingthingsdone.com/][Getting Things Done]] by David Allen: This highly popular "work of the day" got me re-thinking about personal productivity again, and tweaking some of my own practice as a result.
- [[https://www.researchgate.net/publication/222552899_Getting_Things_Done_The_Science_Behind_Stress-Free_Productivity][Getting Things Done: The Science Behind Stress-Free Productivity]] by Francis Heylighen and Clément Vidal: An academic paper on GTD that lays a foundation for what I think is the biggest return on investment for GTD: reducing cognitive stress and overload. No less important, the authors provide an extremely concise and on-point summary of Allen's method, including a comprehensive (wait for it) [[https://www.researchgate.net/profile/Francis-Heylighen/publication/222552899/figure/fig1/AS:304772235186176@1449674771358/a-flowchart-depicting-the-GTD-process-for-organizing-and-processing-incoming-stuff.png][flowchart of the algorithm]]! Recommended reading.
- [[https://www.edwardslingerland.com/trying-not-to-try][Trying Not To Try]] by Edward Slingerland: This trade book is very thought provoking if you have interest in the convergence of history, culture, religion, and creativity. Of most relevance here is the connection to "flow state". Every section of Slingerland's book got me thinking about my own creativity, workplace and historical bias, and where I fit on the spectrum between Confucius and Laozi. /Wu-wei/ ftw!
- [[https://www.youtube.com/watch?v=VcgjTEa0kU4][Org Mode Basics]] and [[https://www.youtube.com/watch?v=PNE-mgkZ6HM][Organize Your Life with Org Mode]] (videos): [[https://systemcrafters.cc/][System Crafters]] is a great source of live code videos and one of the best ways to get into Emacs.

** Emacs Config
If you're interested in my detailed Emacs config, i.e., ~init.el~ you can find my setup in my [[https://github.com/rmorison/dotfiles][GitHub dotfiles repo]]. My Org-mode config started with [[https://www.youtube.com/watch?v=PNE-mgkZ6HM][Organize Your Life with Org Mode]]. If you're new to Emacs or Org-mode, start there.
  
** A Walk-through
The rest of this doc is a walk-through with animated GIFs to illustrate.

*** It All Starts with a Meeting
Let's start with a meeting, which was my original use-case. Alt-tab to Emacs, then ~C-c c m~ to open an entry in ~meetings.org~ from the [[https://github.com/rmorison/dotfiles/blob/main/org/templates/meeting.org][meeting template]]. The template will ask who the meeting is with and what it's about. (There's also a 1-on-1 meeting template, with just the "who?" question, ~C-c c 1~.)

#+CAPTION: Fave Music meeting with Lunis and Lucy
[[./img/new-meeting.gif]]

When the meeting is over and I'm ready to finish the capture I'd normally hit ~C-c C-c~. Instead, I'll use ~C-u C-u C-c C-c~ to /follow/ the capture buffer into the filed location in ~meetings.org~. I'll add a ~TODO~ manually, without a template, by typing ~M-enter~ to open a new outline node and then ~TODO Learn Für Elise on piano~. Text files ftw!

#+CAPTION: File the meeting, create a task 
[[./img/file-meeting.gif]]

*** Check the Backlog, Schedule the Task
~C-c a a~ brings up my agenda for the week. It's empty right now, nothing scheduled. ~C-c a b~ brings up my backlog view. I'll I see the "Learn Für Elise on piano" todo. Using GTD practice, I can either do this right away (2m rule, iirc) and make it DONE, move it to NEXT state, or realize it's too big for a single task and break it up.
#+CAPTION Agenda check
[[./img/check-backlog.gif]]

*** My Algorithm
Now's a good time to highlight the tasks states I use and my typical path through them.
#+begin_src mermaid :file img/task-state-cover.png
stateDiagram-v2
BREAKDOWN: BREAKDOWN-PLAN
INPROGRESS: IN-PROGRESS
HELDBLOCKED: HELD-BLOCKED
WONTDO: WONT-DO
WONTDOPROJECT: WONT-DO
state if_project <<choice>>
state getter_done <<choice>>
state last_mile <<choice>>
state plan_project <<choice>>
[*] --> TODO
TODO --> if_project
if_project --> NEXT: sized and timely
if_project --> BREAKDOWN: too bigga eat
if_project --> WONTDO: not happening
state BREAKDOWN {
  plan_project --> PLANNED: create project tasks
  plan_project --> WONTDOPROJECT: abandon project
  PLANNED --> [*]
  WONTDOPROJECT --> [*]
}
NEXT --> getter_done
getter_done --> INPROGRESS: it's alive!
getter_done --> DELEGATED: tracking
getter_done --> WONTDO: thought so, but no
INPROGRESS --> last_mile
last_mile --> DONE: yay!
last_mile --> WONTDO: changed my mind
last_mile --> HELDBLOCKED: blocked
HELDBLOCKED --> INPROGRESS: unblocked
HELDBLOCKED --> WONTDO: give up
DONE --> [*]
WONTDO --> [*]
#+end_src

#+RESULTS:
[[file:img/task-state-cover.png]]

*** Review Backlog, Schedule Work
~C-c a b~ into my backlog view, I realize my task is a project, too big on its own. (I try to visit the backlog at least once a day.) I'm going to set the task to ~BREAKDOWN-PLAN~. (For example, I have to get a keyboard, buy the sheet music, hire a music teacher) and schedule the planning work for tomorrow.

In the backlog view cursor to the "~TODO~ Learn Für Elise on piano", use ~C-c C-t~ and choose the new state with ~b~. Then, ~C-c C-s~ brings up the calendar. ~S-→~ navigates the calendar. I'll finish with ~C-c a a~ to double check my agenda.
[[./img/schedule-planning.gif]]

*** Check Agenda, Plan Project
Later, I'll check my agenda, ~C-c a a~, arrow down to the ~BREAKDOWN-PLAN~ task, hit ~ENTER~ to jump to the task. I'll drop ~TODO~ entries right under that in the outline. I'll change that ~BREAKDOWN-PLAN~ state to ~PLANNED~, then ~C-x C-s~ to save.
[[./img/plan-project.gif]]

*** Refile Into Projects File, Set Deadlines, Tee up Tasks
Refile is the gem of Org-mode. I don't want to track and annotate my project in my meetings folder, that's not the way. I'm going to move the whole project outline to my projects folder.

~C-x C-f meetings.org~ to open my meetings file, arrow to the ~PLANNED~ project, and ~C-c C-w~ to invoke Org-mode refile. 
[[./img/refile-project.gif]]

*** Prep and Schedule my Backlog
Next, I'll set deadlines and move tasks to ~NEXT~ state. ~C-c a b~ to the backlog, ~C-c C-t n~ for ~NEXT~ state and ~C-c C-d~ to set deadlines, ~C-c C-s~ for scheduled dates. Then I hand edit the "Practice Weekly" task scheduled date for a 1 week [[https://orgmode.org/manual/Repeated-tasks.html][repeated task]]. (Either you love text files, or you don't.)
[[./img/schedule-backlog.gif]]

*** Add Reference Note, Link it in Project
Finally I'll take some historical notes about Für Elise and put a link to those notes into the project outline. I open a reference note with ~C-c c n~ and save it with ~C-u C-u C-c C-c~. The template asks for a title, then I can tap in text. I've bound ~C-c l~ to save an "anchor link" at the current point, and can then open ~projects.org~ and use ~C-c C-l~ to paste it in.
[[./img/note-taking.gif]]

** Features, Features, and more Features
Emacs Org-mode has a dizzying array of [[https://orgmode.org/features.html][features]] and this walk-through is only meant to capture the essence of how I org. I don't use all of these, but for reference, here goes...
- [[https://orgmode.org/manual/Tags.html][Tags]]
- [[https://orgmode.org/manual/Tracking-your-habits.html][Habits]]
- [[https://orgmode.org/manual/Clocking-Work-Time.html][Time tracking]]
- [[https://orgmode.org/worg/org-contrib/babel/][Executing code blocks (Babel)]]
- [[https://orgmode.org/manual/Exporting.html][Exporting]] (say, to markdown or HTML) and [[https://orgmode.org/manual/Publishing.html][publishing]]
- [[https://orgmode.org/worg/org-blog-wiki.html][Blogging and content sites]]

And of course, we're talking Emacs here. If you can code it in Elisp, you can do it.

* DONE Sprint 0.5: Planning a New Service Build
CLOSED: [2022-08-27 Sat 01:06]
:PROPERTIES:
:EXPORT_FILE_NAME: sprint-zero-point-five
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :topics '("Software architecture" "Project management")
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Sprint 0.5: uncovering the hidden work in a new service build"
:EXPORT_HUGO_ALIASES: sprint-0
:END:

** The Sprint 0.5 Scenario
I often come across new, [[https://en.wikipedia.org/wiki/Greenfield_project][greenfield]] backend projects or [[https://en.wikipedia.org/wiki/Brownfield_(software_development)][brownfield]] rewrites of an existing service (usually a monolith) into a new service architecture (usually microservice), and a new infrastructure (cloud migration). It's common---and a best practice---to kick off such a project with a [[https://en.wikipedia.org/wiki/Application_discovery_and_understanding][discovery phase]], unless product requirements are already developed and well understood by the implementation team. The discovery phase is sometime called "Sprint 0", though it's often a much bigger time and effort investment than a common development sprint.

It's also common to invest in some technical architecture and project planning during that discovery sprint. What I've observed in some projects is the technical planning in discovery is just enough for a modicum of work breakdown and estimation. Discovery typically delivers just enough design documentation for feature build tickets or story tasks. However, and especially for a greenfield build, all that planning leaves a host of implementation questions hanging.

Are we set on language, libraries, and web stack? Have we agreed on code formatters, linters, static checkers? What are we using for CI/CD? Do we have a devops plan, to write infrastructure code and bring up multiple environments? And so on.

Sometimes, when an experienced team implements in a familiar organization with established practices, these questions are mostly answered. More often, work such as this creates huge friction in the early sprints and divergence across teams working on different services. And even for the ready-to-roll team, it's worth going through a checklist, look for upgrade opportunities.

The pressure to, "Get going with delivery", can be heavy.  But resist!…if there's a load of these non-recurring tasks hanging unresolved. Get them scheduled in, with full visibility.

I call this /Sprint 0.5/ work: [[https://en.wikipedia.org/wiki/Non-recurring_engineering][NRE]] that has to be done, is better done at the beginning, and creates friction, disorganization, and divergence complexity of not done up front.

** Refine the Architecture, Revisit the Plan
When discovery phase technical architecture, planning and estimation is done, I believe it's worth coming back to at the end of Sprint 0.5. The team has a lot more "feel" for the implementation at this point and is likely to do a deeper dive into tickets and more accurate estimates.

Or, better yet, only do the top level architecture and project breakdown, with minimal [[https://asana.com/resources/t-shirt-sizing][t-shirt size]] accuracy estimation during discovery. Save the deep dive until the tech work of Sprint 0.5 is done.

Of course, commitment to stakeholders, budget and deadline pressure may make this untenable. But at least validate your discovery project plan and estimates. And if Sprint 0.5 estimates are significantly greater than those from discovery, well that's another problem.
[[./img/brown_and_black_turtle_on_brown_sand-scopio-01f822e0-47d5-4952-b881-2331aa99c598.jpg]]

** Sprint 0.5 Project Breakdown
Here I offer a canonical work breakdown for a sprint 0.5. The epics breakdown are part of a more detailed breakdown in this [[https://docs.google.com/spreadsheets/d/1VmFfYiROtW4wktL4Exlz9NODEgOy4tTJb9lJS5lP9EE/edit?usp=sharing][Sprint 0.5 project breakdown]] Google sheet.

+---------------------------+----------------------------------------------------------------+
|Epic                       |Tasks                                                           |
+---------------------------+----------------------------------------------------------------+
|Service stack template(s)  |Select language, libraries, web stack for service and serverless|
|                           |implementations; build out a "cookiecutter" template project;   |
|                           |add standardized test runner, coverage, linters, static         |
|                           |checkers, and formatters.                                       |
+---------------------------+----------------------------------------------------------------+
|Continuous integration (CI)|Decide on CI (Jenkins, GH Actions, BB Pipelines, Travis,        |
|                           |CircleCI); setup servers and/or runners; containerize template  |
|                           |service(s); add test, lint, format to CI; add Dockerfile, CI to |
|                           |templates                                                       |
+---------------------------+----------------------------------------------------------------+
|Cloud infrastructure       |Build an environment in infrastructure with template service(s):|
|                           |container strategy (orchestration, etc), networking, databases, |
|                           |proxies, load balancers; implement with infrastructure code and |
|                           |validate with env spinup                                        |
+---------------------------+----------------------------------------------------------------+
|Continuous deployment (CD) |Establish branch/release/env SDLC strategy; connect service     |
|                           |builds with env deploys                                         |
+---------------------------+----------------------------------------------------------------+
|Logging & monitoring       |Setup logging, APM, trace in service stack and feed to central  |
|                           |logging; setup service health checks; add anomaly alerting      |
|                           |(Slack, SMS, Pagerduty)                                         |
+---------------------------+----------------------------------------------------------------+
|Service architecture       |Design entities, APIs, async tasks, etc. for initial set of     |
|                           |services, including registration/authentication                 |
+---------------------------+----------------------------------------------------------------+
|Planning & estimating      |Use architecture level design for implementation stories,       |
|                           |estimates, and scheduling                                       |
+---------------------------+----------------------------------------------------------------+
|Initial build: sprint 1,2,…|At this point each service can drop a code template with CI/CD  |
|                           |ready to go and start a sequence of delivery sprints            |
+---------------------------+----------------------------------------------------------------+

** A Sprint 0.5 Gantt Chart
As a practical matter of efficiency, much of Sprint 0.5 can be split among software architects, developers, and devops staff, allowing work in parallel, as suggested below.

#+begin_src mermaid :file img/sprint-0.5-gantt.png
gantt
    title Sprint 0.5 Project Plan
    dateFormat DD
    axisFormat %d
    section Discovery
    Discovery           :discovery, 01, 2d
    section Sprint 0.5
    Service stack template(s) :templates, after discovery, 1d
    Continuous integration (CI) :ci, after templates, 1d
    Cloud infrastructure :infra, after discovery, 2d
    Continuous deployment (CD) :cd, after infra, 1d
    Logging & monitoring :logging, after cd, 1d
    Service architecture :arch, after ci, 1d
    Planning & estimating :planning, after arch, 1d
    Sprint 0.5 complete :milestone, after planning
    section Delivery
    Sprint 1 :sprint1, after planning, 1d
    Sprint 2 :sprint2, after sprint1, 1d
#+end_src

* DONE Bringup up Backstage (with Docker Compose)
CLOSED: [2023-01-01 Sun 19:22]
:PROPERTIES:
:EXPORT_FILE_NAME: bringing-up-backstage
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :topics '("Backstage" "Software architecture" "Docker")
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "How to host a backstage.io instance with Docker compose"
:END:
** Backstage (for people in a hurry)
*** Motivation
This how-to covers a relatively lightweight hosting for [[https://backstage.io/][Backstage]], Spotify's open source developer portal.
[[./img/black_and_gray_audio_mixer-scopio-243550cf-d8ba-4858-ac48-89a1eaa7681e.jpg]]

Many of the challenges that emerge as an engineering team scales--from 5 to 15, then 15 to 50, just about every factor of 2 or 3--can be traced back to something that could have been done better in a previous stage. Those challenges include documentation, architecture, code layout, and, CI/CD practice, to name a few. As deficiencies in these are identified in past work they get lumped into the [[https://en.wikipedia.org/wiki/Technical_debt][tech debt]] basket.

Does Backstage really help promote good engineering and beat back tech debt before it happens? I'm still at an experimental, proof of concept stage with Backstage, and hope to tackle that question in future articles.
*** The Problem
The [[https://backstage.io/docs/overview/what-is-backstage][Backstage docs]] are extensive, but hard to follow. Those docs jump back and forth between local configuration, plugin setups, plugin options, deployment suggestions, and more. I characterize the Backstage docs as everything, everywhere, all over the place! Maybe it's just me?

Yes, there's a [[https://demo.backstage.io/catalog?filters%5Bkind%5D=component&filters%5Buser%5D=owned][Backstage demo site]] for a quick look. The [[https://backstage.io/docs/getting-started/][Backstage getting started]] section walks through bringing up a site locally. But collaboration is what Backstage is all about; I need a shared instance to really kick the tires. (There are excellent hosted service options, such as [[https://roadie.io/][Roadie]], if you have the budget.)

So, what if you want to bring up Backstage for a small team, open source project, or a hackathon? I could not find a quick and easy setup for Backstage, something with modest effort before a =docker compose up= brings joy. The [[https://backstage.io/docs/deployment/][Backstage Deployment]] docs amount to helpful, but incomplete notes for bringing up a shared instance.
** Scope
This document walks through a Docker Compose setup for Backstage with its core features:  [[https://backstage.io/docs/features/techdocs/techdocs-overview][TechDocs]], [[https://backstage.io/docs/features/software-catalog/software-catalog-overview][Software Catalog]], and [[https://backstage.io/docs/features/software-templates/software-templates-index][Software Templates]]. In particular, the only infrastructure assumption is a publicly accessible, Docker ready server (AWS EC2, Digital Ocean, bare metal, etc.).

In this setup there is no TechDocs reliance on cloud storage; TechDocs will be stored in a shared Docker volume and published from a CI workflow, analogous to [[https://backstage.io/docs/features/techdocs/configuring-ci-cd][Backstage's cloud storage]] recommended practice.
** Tl;Dr
If you're /really/ in a hurry and already familiar with building Backstage, head over to my [[https://github.com/rmorison/backstage-docker][backstage-docker]] repo. You can likely stitch things together from the minimal docs there.
** What You'll Need
- A GitHub account or organization
- A server with [[https://docs.docker.com/engine/install/][Docker installed]]
- A local "developer" system 
** Step by step
We'll walk through creating a new backstage app repository, configuring it for this setup, setting up CI/CD to build the app, the server hosting, and end with publishing CI for TechDocs.
*** Prerequisites
Install and configure all of the tools for local backstage dev, per the [[https://backstage.io/docs/getting-started/#prerequisites][Backstage prerequisites]].
*** Create your app
We'll call our app ~backstage-app~. In a shell, ~cd~ to where you'd like to setup this project, and
#+begin_src shell
  npx @backstage/create-app
#+end_src
and at the ~Enter a name for the app [required]~ prompt, enter ~backstage-app~ (or another name of your choosing).

And with that, we have an app ready to run locally with ~yarn dev~. Developing on the local instance is covered in the [[https://backstage.io/docs/getting-started/configuration][Getting Started, configuring Backstage]] section. You can check your build and run locally with
#+begin_src shell
  cd backstage-app
  yarn dev
#+end_src

This article doesn't cover developing for Backstage or [[https://backstage.io/docs/plugins/create-a-plugin][Backstage plugins]]. We'll move on to production configuration, CI/CD, and hosting.
*** Create Repo and Push
This guide uses GitHub Actions for CI. Create a new repo for ~backstage-app~ with an individual or organization owner. No need for any perfunctory files (README, .gitignore, license), as we'll push our app into this repo.

[[./img/create-new-backstage-app-repo.png]]

Setup the remote in your local ~backstage-app~ repo and push the initial commit (from the create-app script):
#+begin_src shell
  git remote add origin git@github.com:your-name-here/backstage-app.git
  git branch -M main
  git push -u origin main
#+end_src
**** Make sure ~yarn.lock~ is updated
Backstage starts with an empty ~yarn.lock~ file. (If you ran ~yarn dev~ you probably filled this in.) Update and commit that file.
#+begin_src shell
  yarn build:all
  git add yarn.lock
  git commit -m 'lock js packages'
#+end_src
*** Docker Image CI
With our repo up, we can setup a Docker image CI. Backstage ships with a Dockerfile we'll use in ~packages/backend/Dockerfile~. Note the ~CMD~ at the end of the Dockerfile.
#+begin_src shell
CMD ["node", "packages/backend", "--config", "app-config.yaml", "--config", "app-config.production.yaml"]
#+end_src

Backstage will configure from ~app-config.yaml~ first and ~app-config.production.yaml~ second, the latter taking precedence. We'll edit ~app-config.production.yaml~ for our hosting.

But first, let's setup CI. We'll borrow from the [[https://github.com/backstage/backstage/blob/master/.github/workflows/deploy_docker-image.yml][Backstage repo GitHub action]], with some changes...
- remove yarn caching
- change the ~on:~ section to build on push to ~main~ branch or via [[https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch][workflow_dispatch]] (so we can trigger a build on a feature branch)
- build in ~.~ rather than ~./example-app~

Create ~.github/workflows/deploy_docker-image.yaml~, copying from [[https://github.com/rmorison/backstage-app/blob/main/.github/workflows/deploy_docker-image.yaml][deploy_docker-image.yaml]].

Add to the repo and push
#+begin_src shell
  git add .github/workflows/deploy_docker-image.yaml
  git commit -m 'Workflow: Build and push Docker image'
  git push
#+end_src

That should kick off a build.
[[./img/test-backstage-app-build-workflow.png]]

After 4-5 minutes you should see the workflow complete and can visit repo packages (look for the Packages section in the repo home screen):
[[./img/backstage-app-image-in-ghcr.png]]

*** App Config
Make the following config changes in ~app-config.production.yaml~.

**** Edit ~app~ and ~organization~
In the ~app~ seciton set ~title~ to  ~${BACKSTAGE_APP_TITLE}~ env var and ~baseUrl~ to ~https://${BACKSTAGE_DOMAIN}~.

In the ~organization~ section set ~name~ to ~${BACKSTAGE_ORGANIZATION_NAME}~.

These will be configured from Docker Compose environment settings.
#+begin_src yaml
  app:
    title: ${BACKSTAGE_APP_TITLE}
    baseUrl: https://${BACKSTAGE_DOMAIN}

  organization:
    name: ${BACKSTAGE_ORGANIZATION_NAME}
#+end_src

**** Edit ~backend~
Change the ~backend~ ~baseUrl~ and ~listen~ sections as follows, leaving the ~database~ section as is
#+begin_src yaml
  backend:
    baseUrl: https://${BACKSTAGE_DOMAIN}
    listen:
      port: '7007'
      host: '0.0.0.0'

    database:
      client: pg
      connection:
        host: ${POSTGRES_HOST}
        port: ${POSTGRES_PORT}
        user: ${POSTGRES_USER}
        password: ${POSTGRES_PASSWORD}
#+end_src

**** Edit ~catalog~
Replace the ~catalog~ section with
#+begin_src yaml
catalog:
  import:
    entityFilename: catalog-info.yaml
    pullRequestBranchName: backstage-integration
  rules:
    - allow: [Component, System, API, Resource, Location, Template, User, Group]
#+end_src
Later, you may want to come back and add standard locations for some entity types, Users and Groups for example. But keep it simple for now, until the system is up and running.

**** Edit ~techdocs~
[[https://backstage.io/docs/features/techdocs/techdocs-overview][TechDocs]] is Backstage's "docs as code" framework. TechDocs Markdown documents under a repository's ~docs~ tree and publishes it to a browsable, searchable documentation site. We'll setup CI/CD per the [[https://backstage.io/docs/features/techdocs/architecture#recommended-deployment][TechDocs recommended deployment]], except that the publish step will be replaced by secure copy to a volume in the Backstage Docker cluster, instead of cloud storage.

That means the ~techdocs~ section ~builder~ should be set to ~external~. The ~publisher~ section needs to point at a local directory path. Append the following to ~app-config.production.yaml~
#+begin_src yaml
  techdocs:
    builder: 'external'
    publisher:
      type: 'local'
      local:
        publishDirectory: ${TECHDOCS_DIR}
#+end_src
We'll setup a TechDocs publish action later.

**** Commit and Push
That's our production config. Your config should look like [[https://github.com/rmorison/backstage-app/blob/main/app-config.production.yaml][app-config.production.yaml]]; when you're ready, add, commit, and push.
#+begin_src shell
  git add app-config.production.yaml
  git commit -m "Production app config"
  git push
#+end_src
The "Build and push Docker image" action should trigger, check when done for status.

*** Update Backstage Catalog, Setup TechDocs

**** Update ~catalog-info.yaml~
The app was created with a scaffolded ~catalog-info.yaml~, which needs some edits. We'll also add TechDocs support and a simple doc to validate the build.

In the ~metadata~ section, change ~description~ to your repo description (or whatever you like).

Uncomment the ~annotations~ section. Change the ~github.com/project-slug~ to your repo path (minus the github.com part) and leave ~backstage.io/techdocs-ref~ as is (~dir:.~).

Under ~spec~ change ~owner~ to your Github id (recommended) or email. You can change this once you settle on an identity scheme, which is a topic for another day.

Your ~catalog-info.yaml~ should look like
#+begin_src yaml
  apiVersion: backstage.io/v1alpha1
  kind: Component
  metadata:
    name: backstage-app
    description: My Backstage application.
    annotations:
      github.com/project-slug: my-github-id/backstage-app
      backstage.io/techdocs-ref: dir:.
  spec:
    type: website
    owner: my-github-id
    lifecycle: experimental
#+end_src

**** Setup TechDocs
In addition to the ~backstage.io/techdocs-ref: dir:.~ in ~catalog-info.yaml~, TechDocs requires a ~mkdocs.yml~. Add that file to the top of your repo with the following
#+begin_src yaml
  site_name: 'backstage-app'

  nav:
    - Home: index.md

  plugins:
    - techdocs-core

  markdown_extensions:
    - markdown_inline_mermaid
#+end_src

Add some documentation, create ~docs/index.md~ with
#+begin_src markdown
  # Hello World!

  ```mermaid
  sequenceDiagram
      Alice->>John: Hello John, how are you?
      John-->>Alice: Great!
      Alice-)John: See you later!
  ```	
#+end_src

**** Commit and Push
#+begin_src shell
  git add catalog-info.yaml mkdocs.yml docs
  git commit -m "Update catalog-info, add TechDocs"
  git push
#+end_src

*** Docker Compose Setup
With our Docker image built, time to get it running on a server. We'll use the ~docker-compose.yml~ I've built in the [[https://github.com/rmorison/backstage-docker][backstage-docker repo]]. The configuration instructions are documented there, so we'll just mimic the [[https://github.com/rmorison/backstage-docker#step-by-step][Step by Step]] here. Be sure to review [[https://github.com/rmorison/backstage-docker#env-docs][env setup]] carefully, most problems trace back to a setting in that file.

On your server
#+begin_src shell
  git clone git@github.com:rmorison/backstage-docker.git
  cd backstage-docker
  cp sample.env .env
  vi .env
  sudo apt install --yes apache2-utils
  htpasswd -bn backstage change-this-password >>.htpasswd
#+end_src

Before you bring up your server, be sure to point a domain name at your server's public IP address. The Let's Encrypt ssl cert validation will fail if you don't.

With that done,
#+begin_src shell
  docker compose up --build
#+end_src
and try accessing your new server from a browser.

Test your new backstage by adding the backstage-app component: hit "Create...", then "REGISTER EXISTING COMPONENT", then enter the url to your ~catalog-info.yaml~ file.
[[./img/register-existing-component.png]]

If all is good, you should have a registered backstage component, like
[[./img/backstage-app-component.png]]

However, if you click on the "VIEW TECHDOCS" link, you'll get an error.
[[./img/techdocs-someone-dropped-the-mic.png]]

Adding our component doesn't automatically publish its TechDocs, since we've chosen an external builder (in ~app-config.production.yaml~), so that's on us.

Next, we'll setup a Github Action to publish to our compose cluster.

*** TechDocs Publish CI

The external builder setting in ~app-config.production.yaml~ is the Backstage recommended practice. But that means each repo with TechDocs needs a publish CI setup. We'll create a ~techdocs.yaml~ workflow, fashioned after [[https://backstage.io/docs/features/techdocs/configuring-ci-cd#example-github-actions-ci-and-aws-s3][Example: GitHub Actions CI and AWS S3]]. We'll replace AWS S3 storage with an ~scp~ and swap out the PlantUML support, in favor of [[https://mermaid.js.org/#/][MermaidJS]]. (Mermaid is a diagramming tool that is also [[https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/][supported in Github Markdown rendering]].) Note that Backstage's [[https://backstage.io/docs/features/techdocs/how-to-guides#how-to-add-mermaid-support-in-techdocs][How to add Mermaid support in TechDocs]] procedure uses a separate [[https://kroki.io/][Kroki]] server, which we don't follow here, favoring a simpler "full static" approach.

Create ~.github/workflows/techdocs.yaml~, and copy in the contents of this [[https://github.com/rmorison/backstage-app/blob/main/.github/workflows/techdocs.yaml][techdocs.yaml]].

The one workflow step to note---and the most common source of errors---is the "Publish docs site via scp" step. The Docker cluster has a SSH service running on port 2222, which needs to be open on the firewall to your server. That SSH service can write to the Docker volume where Backstage looks for TechDocs, if you recall the ~techdocs~ section of our config. (That OpenSSH server is configured [[https://github.com/rmorison/backstage-docker/blob/main/docker-compose.yml#L62][here]] in the compose file, in case you're looking.)
#+begin_src yaml
      - name: Publish docs site via scp
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.TECHDOCS_HOST }}
          key: ${{ secrets.TECHDOCS_SSH_PRIVATE_KEY }}
          username: techdocs
          port: 2222
          source: site
          target: /techdocs/${{ env.ENTITY_NAMESPACE }}/${{ env.ENTITY_KIND }}/${{ env.ENTITY_NAME }}
          strip_components: 1
          rm: true
#+end_src
Note the two secrets. These go in your Github repo action secrets. ~TECHDOCS_HOST~ is the domain name pointing at your server.

If you followed the [[https://github.com/rmorison/backstage-docker#techdocs-publish-ssh-keypair][TechDocs Publish SSH Keypair]] section you already have the private key. (If not, do that now, and update your ~.env~ with the *public* key, restart your cluster.) The ~TECHDOCS_SSH_PRIVATE_KEY~ in your repo actions secrets gets the contents of the private key file, ~techdocs_rsa~. 

And finally, note ~target:~. This value has to be just right for Backstage to find TechDocs. In particular, ~ENTITY_KIND~ must be lower case, which you'll see a previous action step for.

With that, commit, push, watch the action run, and try "VIEW TECHDOCS" again.
#+begin_src shell
  git add .github/workflows/techdocs.yaml
  git commit -m 'Workflow: Publish docs site via scp'
  git push
#+end_src

If all goes well...
[[./img/techdocs-works-yay.png]]

If not, it's time to debug.
** Are we done yet?
Backstage absolutely has a cost of ownership. The goal of this article is to make quick self hosting palatable for small projects and teams. If a Backstage adoption is successful and the team or scope grows, maintaining and evolving Backstage is a full time job. Again, there are excellent hosted versions, like [[https://roadie.io/][Roadie]], if you have a budget.

Is the value proposition worth it? That's a topic for another day.

* TODO Running TechDocs locally
When writing docs it's often desirable to see them rendered before published. The Backstage project provides a [[https://github.com/backstage/techdocs-container][techdocs-container]] that can build and serve locally, but it does not include Mermaid support. We'll run [[https://backstage.io/docs/features/techdocs/cli][techdocs-cli]] locally, outside Docker. You'll need to install [[https://www.mkdocs.org/][Mkdocs]], a Python app, with TechDocs and Mermaid support.

** TechDocs local setup requirements

- This setup assumes a Python 3 installation, [[https://github.com/pyenv/pyenv][pyenv]] recommended, but any working Python 3 setup will do.

- We'll use [[https://pypa.github.io/pipx/][pipx]] to install and extend Mkdocs. (Pipx installs Python apps each in their own virtual package environment, thus avoiding any package compatibility conflict with other Python apps.)

** Install TechDocs and Mermaid CLIs
#+begin_src shell
  npm install -g @techdocs/cli
  npm install -g @mermaid-js/mermaid-cli
#+end_src

** Install pipx with TechDocs and Mermaid support
#+begin_src shell
  pipx install mkdocs==1.*
  pipx inject mkdocs mkdocs-techdocs-core==1.*
  pipx inject mkdocs markdown-inline-mermaid==1.*
#+end_src

** Setup TechDocs in your backstage-app repo
Per [[https://backstage.io/docs/features/techdocs/creating-and-publishing#enable-documentation-for-an-already-existing-entity][Enable documentation for an already existing entity]]
- Create an ~mkdocs.yml~, including the Mermaid plugin
  #+begin_src yaml
    site_name: 'backstage-app'

    nav:
      - Home: index.md

    plugins:
      - techdocs-core

    markdown_extensions:
      - markdown_inline_mermaid
  #+end_src
- Update ~catalog-info.yaml~
  #+begin_src yaml
    metadata:
      annotations:
        backstage.io/techdocs-ref: dir:.
  #+end_src
  - Create documentation, in ~docs/index.md~
  #+begin_src markdown
    # Hello World!

    ```mermaid
    sequenceDiagram
        Alice->>John: Hello John, how are you?
        John-->>Alice: Great!
        Alice-)John: See you later!
    ```	
  #+end_src
- Serve docs
  #+begin_src shell
    techdocs-cli serve --no-docker
  #+end_src

* TODO Backstage, an Engineering Collaboration Framework

** For Management
After finally wrapping my head around Backstage, I think it's miscast. Or at least, mismarketed, to engineering managers. The problem may lie in the fact it's an engineering management tool for engineers. Engineering managers don't typically think this way: how can I make my engineers more productive when they work with other engineers in the organization.

In fact, Backstage is going to succeed where engineers---and more progressive engineering managers---buy into engineers managing up and out. The metric of success, in my opinion, the KPI if you must, is whether every engineer on every team is utilizing, contributing to, and thinking about their Backstage presence every day.

Backstage is a collaboration framework for engineering across teams. That puts backstage in a tricky position. It's core data is developed, written and maintained by engineers. However, Backstage needs support across teams for its implementation. And 

* TODO Emacs IDE FTW
:PROPERTIES:
:EXPORT_FILE_NAME: emacs-ide-ftw
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :topics '(Emacs Python Go)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Emacs as an IDE: LSP and DAP turns Emacs into an IDE (with a little elbow grease)"
:END:
* TODO Local Hero, A Retrospective Review

** We need each other (connection)

** The egoist's life, well lived

** Urban life, challenged with alternatives

** Rustic life, wishing on a dream

** A man of faith, an African, not a Scotsman

** Born to roam
* TODO Climate References

** A Quantitative Snapshot of the Human Impact on the Planet
- [[https://www.caltech.edu/about/news/the-human-impact-on-the-environment][Press release]]
- 
- 

** Aspiration and Imperative Global Partner on High-Quality Carbon Offset Projects
- [[https://www.linkedin.com/pulse/aspiration-imperative-global-partner-high-quality-carbon-/][Press release]]
*** About Imperative Global Group, Inc.
#+begin_quote
Imperative is a mission driven, boots-on-the-ground business focused on bringing excellence to carbon offset project development and operation and on producing ultra-high quality carbon offsets. Imperative brings together multi-decade experience in carbon and conservation projects, carbon markets, major project execution and emerging market, cross-border structuring and finance. In order to drive the largest and best possible climate, sustainable development and biodiversity outcomes, Imperative is focused on emerging markets and on project types with the greatest opportunities for scale.
#+end_quote
** Expert Voices: Aspiration CEO Andrei Cherny
- [[https://www.axios.com/pro/climate-deals/2022/07/08/expert-voices-aspiration-ceo-andrei-cherny][Interview (subscriber only)]]
* TODO How to Test a Cookiecutter
